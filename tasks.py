__author__ = "Eargosha"
from myMath import *
import numpy as np

# 136и: Даны натуральное число n, действительные числа a1,..., an.
def task136(n, a):
    """
    Требуется вычислить сумму: a1/1! + a2/2! + ... + an/n!

    :param n: Натуральное число (длина последовательности).
    :param a: Список действительных чисел длины n.
    :return: Результат суммы
    """
    # Проверяем, что n является натуральным числом (n ≥ 1).
    # Если n <= 0, выбрасываем исключение ValueError с соответствующим сообщением.
    if n <= 0:
        raise ValueError("n должно быть натуральным числом (n ≥ 1)")

    # Проверяем, что длина списка a равна n.
    # Если длина a не соответствует n, выбрасываем исключение ValueError.
    if len(a) != n:
        raise ValueError("Длина списка a не соответствует n")

    # Инициализируем переменную total для хранения результата суммы.
    total = 0.0

    # Проходим по всем натуральным числам от 1 до n включительно.
    for i in range(1, n + 1):
        # Добавляем к total слагаемое a[i-1] / factorial(i),
        # где a[i-1] — это i-й элемент списка а (учитывая, что индексация начинается с 0),
        # а factorial(i) — факториал числа i.
        total += a[i - 1] / factorial(i)

    # Возвращаем вычисленную сумму.
    return total


# 178б: Даны натуральные числа n, a 1...an. Определить количество членов ak последовательности
# a1, ..., an кратных 3 и не кратных 5;
def task178(n, a):
    """
    Функция для подсчета количества элементов в последовательности,
    которые кратны 3 и не кратны 5.

    :param n: Натуральное число (длина последовательности).
    :param a: Список действительных чисел длины n.
    :return: Количество элементов, удовлетворяющих условиям.
    """
    # Проверяем, что n является натуральным числом (n ≥ 1).
    if n <= 0:
        raise ValueError("n должно быть натуральным числом (n ≥ 1)")

    # Проверяем, что длина списка a соответствует n.
    if len(a) != n:
        raise ValueError("Длина списка a не соответствует n")

    # Инициализируем счетчик для хранения количества подходящих элементов.
    count = 0

    # Проходим по всем элементам последовательности.
    for element in a:
        # Проверяем два условия
        if element % 3 == 0 and element % 5 != 0:
            # Если оба условия выполняются, увеличиваем счетчик.
            count += 1

    # Возвращаем значение счетчика.
    return count


# 335в. Дано натуральное число n. Вычислить Sum(1/(k^2)!) from 1 to n where k=1
def task335(n):
    """
    Функция для подсчета суммы элементов в последовательности: Sum(1/(k^2)!) from 1 to n where k=1

    :param n: Натуральное число (длина последовательности).
    :return: Результат суммы
    """
    result = 0.0
    # Да
    for k in range(1, n + 1):
        result += 1 / factorial(k ** 2)
    return result


def left_bottom_corner(matrix):
    """
    Функция для отбрасывания всех элементов матрицы кроме левого нижнего угла

    :param matrix: матричка.
    :return: Результат отбрсаывания
    """
    # Определяем количество строк и столбцов в матрице
    rows, cols = matrix.shape

    # Вычисляем половину размера матрицы
    rows_to_keep = rows // 2
    cols_to_keep = cols // 2

    # Оставляем только элементы в левом нижнем углу
    result = matrix[-rows_to_keep:, :cols_to_keep]
    return result


class OPERATIONSINTASK677:
    Sum = 'sum'
    sum = 'sum'
    Prod = 'prod'
    prod = 'prod'
    Max = 'max'
    max = 'max'
    Min = 'min'
    min = 'min'


# Дана действительная матрица [aij]i, i = 1, ..., n. Получить действительную матрицу [bij]i, i = 1, ..., n
# элемент bij которой равен сумме элементов данной матрицы расположенных в области, определяемой индексами i,j так,
# как показано на рисунке (область заштрихована). Сходным образом можно рассмотреть вместо суммы элементов их
# произведение, наибольшее значение, наименьшее значение.
def task677(a, operation):
    """
    Функция для вычисления матрицы [Bij], где каждый элемент Bij равен:
    - сумме элементов,
    - произведению элементов,
    - наибольшему значению,
    - наименьшему значению
    матрицы a, расположенных в области от начала до элемента [i,j].

    :param a: Исходная матрица a. Это объект типа ndarray.
    :param operation: Тип операции ('sum', 'prod', 'max', 'min').
    :return: Матрица b с результатами выбранной операции.
    """
    # Проверка допустимости операции
    if operation not in [OPERATIONSINTASK677.Sum, OPERATIONSINTASK677.Prod, OPERATIONSINTASK677.Max, OPERATIONSINTASK677.Min]:
        raise ValueError("Недопустимое значение параметра operation. Выберите из 'sum', 'prod', 'max', 'min'.")

    # Создаем обрезанную матрицу, ну че поделать, жизнь такая
    b = left_bottom_corner(a)

    # Выбор операции и вычисление матрицы
    if operation == OPERATIONSINTASK677.Sum:
        """ Метод cumsum вычисляет накопительную (кумулятивную) сумму элементов массива.
            Параметр axis определяет направление суммирования:
            axis=0: суммирование по строкам (вниз по столбцам).
            axis=1: суммирование по столбцам (вправо по строкам)."""
        return np.cumsum(np.cumsum(b, axis=0), axis=1)
    elif operation == OPERATIONSINTASK677.Prod:
        """ Метод cumprod вычисляет накопительное произведение элементов массива.
            Работает аналогично cumsum, но вместо суммирования выполняется умножение."""
        return np.cumprod(np.cumprod(b, axis=0), axis=1)
    elif operation == OPERATIONSINTASK677.Max:
        """ Находит максимум, вау."""
        return b.max()
    elif operation == OPERATIONSINTASK677.Min:
        """ Находит минимум, вау."""
        return b.min()