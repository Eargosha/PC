#pragma warning disable CA1416
using System;
using System.Collections.Concurrent; // Пространство имен содержит классы, которые обеспечивают потокобезопасные коллекции
using System.Threading.Tasks;

class Program
{
    /// <summary>
    /// Передавать очередь в параметрах косюмера и продюсера, т.е. сделать их в отдельном классе наверное?
///!!!!    Отдельные модули сделать для продюсера и консюмера и функций связанных с температурой


    /// </summary>
    static void Main()
    {
        // Создаем очередь с ограниченной емкостью
        var queue = new BlockingCollection<TemperatureMarks>(boundedCapacity: 10);

        Console.WriteLine("Нажмите Ctrl+C, чтобы остановить мониторинг...");

        // Обработка события нажатия Ctrl+C для корректного завершения работы
        Console.CancelKeyPress += (s, e) =>
        {
            // s - Sender, Представляет объект, который инициировал событие. В данном случае это объект Console
            // e - EventArguments, Это объект типа ConsoleCancelEventArgs, который содержит информацию о событии
            // Cancel (bool): Если установить e.Cancel = true, программа не завершится сразу после нажатия Ctrl+C. Это позволяет выполнить дополнительные действия перед завершением

            // Сообщаем очереди, что больше не будет новых данных
            // CompleteAdding помечает BlockingCollection<T> как не допускающей добавления дополнительных элементов
            // После того как коллекция будет помечена как завершенная для добавления, добавление в коллекцию запрещено,
            // и попытки удаления из коллекции не будут ждать, когда коллекция пуста.
            queue.CompleteAdding(); // Сообщаем очереди, что больше не будет новых данных
            e.Cancel = true; // Отменяем стандартное поведение завершения программы
        };

        // Создаем задачу для производителя
        Task producer = Task.Run(() => Producer());

        // Получаем количество консюмеров из кол-ва ядер процессора
        int consumerCount = Environment.ProcessorCount;
        Console.WriteLine($"Количество ядер процессора и консюмеров: {consumerCount}");

        // Создаем массив ссылок на задачи потребителей кол-ва consumerCount
        Task[] consumers = new Task[consumerCount];
        for (int i = 0; i < consumerCount; i++)
        {
            int id = i + 1; // Номер потребителя
            // Каждая задача будет работать в фоновом режиме, выполнять переданную лямбда функцию
            // Task.Run - метод, что запускает асинхронную задачу и запускает ее в пуле потоков
            consumers[i] = Task.Run(() => TemperatureConsumer.Consume(id, queue));
        }

        // Дожидаемся завершения всех задач потребителей, блокируя основной поток и не завершая основной поток
        Task.WaitAll(consumers);

        Console.WriteLine("Мониторинг за температурой завершен.");
    }
}